name: Deploy to Azure Container Instances

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (e.g., main-abc1234)'
        required: true
        type: string
  workflow_run:
    workflows: ["Build and Push to Azure Container Registry"]
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ${{ secrets.ACR_REGISTRY }}
  IMAGE_NAME: no-weak-links
  CONTAINER_GROUP_NAME: no-weak-links-app
  RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  LOCATION: ${{ secrets.AZURE_LOCATION || 'eastus' }}

permissions:
  contents: read
  id-token: write
  attestations: read

jobs:
  verify-and-deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "IMAGE_TAG=${{ inputs.image_tag }}" >> $GITHUB_ENV
          else
            # For workflow_run trigger, use the full SHA from the triggering workflow
            # Note: head_sha provides the full commit SHA
            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            echo "IMAGE_TAG=main-${COMMIT_SHA}" >> $GITHUB_ENV
          fi
          echo "Image tag set to: ${IMAGE_TAG}"

      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_REGISTRY }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Pull image to get digest
        id: pull-image
        run: |
          IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "Pulling image: $IMAGE_REF"
          docker pull "$IMAGE_REF"
          
          # Get the image digest
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE_REF" | cut -d'@' -f2)
          
          # Verify digest is not empty
          if [ -z "$IMAGE_DIGEST" ]; then
            echo "‚ùå Failed to extract image digest"
            exit 1
          fi
          
          echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> $GITHUB_ENV
          echo "Image digest: $IMAGE_DIGEST"

      - name: Verify image provenance
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Verifying provenance for image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ env.IMAGE_DIGEST }}"
          
          # Verify the attestation using GitHub CLI
          gh attestation verify oci://${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ env.IMAGE_DIGEST }} \
            --owner ${{ github.repository_owner }}
          
          echo "‚úÖ Provenance verification successful!"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Azure Container Instances
        run: |
          IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ env.IMAGE_DIGEST }}"
          
          echo "Deploying verified image: $IMAGE_REF"
          
          # Check if container group exists and delete it to ensure fresh deployment
          if az container show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_GROUP_NAME }} &>/dev/null; then
            echo "Existing container found, deleting..."
            az container delete \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name ${{ env.CONTAINER_GROUP_NAME }} \
              --yes
            
            # Wait for deletion to complete
            echo "Waiting for deletion to complete..."
            MAX_WAIT=60
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              if ! az container show \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --name ${{ env.CONTAINER_GROUP_NAME }} &>/dev/null; then
                echo "Container deleted successfully"
                break
              fi
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done
          fi
          
          # Create new container with verified image
          # Use a stable DNS name for consistent access
          DNS_LABEL="no-weak-links-app"
          
          az container create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_GROUP_NAME }} \
            --image "$IMAGE_REF" \
            --registry-login-server ${{ env.REGISTRY }} \
            --registry-username ${{ secrets.ACR_USERNAME }} \
            --registry-password ${{ secrets.ACR_PASSWORD }} \
            --dns-name-label "$DNS_LABEL" \
            --ports 8080 \
            --cpu 1 \
            --memory 1 \
            --restart-policy OnFailure \
            --environment-variables \
              PORT=8080

      - name: Get deployment URL
        run: |
          FQDN=$(az container show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_GROUP_NAME }} \
            --query ipAddress.fqdn \
            --output tsv)
          
          echo "üöÄ Application deployed successfully!"
          echo "üìç URL: http://${FQDN}:8080"
          echo "deployment_url=http://${FQDN}:8080" >> $GITHUB_OUTPUT

      - name: Verify deployment health
        run: |
          FQDN=$(az container show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.CONTAINER_GROUP_NAME }} \
            --query ipAddress.fqdn \
            --output tsv)
          
          echo "Waiting for container to be ready..."
          
          # Retry health check with timeout
          MAX_ATTEMPTS=10
          ATTEMPT=0
          SLEEP_TIME=10
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT of $MAX_ATTEMPTS..."
            
            if curl -f -s "http://${FQDN}:8080/health" > /dev/null 2>&1; then
              echo "‚úÖ Health check successful!"
              curl "http://${FQDN}:8080/health"
              exit 0
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "Health check failed, waiting ${SLEEP_TIME}s before retry..."
              sleep $SLEEP_TIME
            fi
          done
          
          echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
          exit 1
